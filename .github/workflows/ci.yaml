name: Build and Deploy Docker Image

on:
  push:
    branches:
      - main
      - "module/*"    # Branches de modules g√©n√©r√©s automatiquement

permissions:
  contents: read
  packages: write
  actions: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      branch_name: ${{ steps.branch-info.outputs.branch_name }}
      is_module_branch: ${{ steps.branch-info.outputs.is_module_branch }}
      module_name: ${{ steps.branch-info.outputs.module_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Extract branch info
        id: branch-info
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT

          # Check if this is a module branch
          if [[ "$BRANCH_NAME" == module/* ]]; then
            echo "is_module_branch=true" >> $GITHUB_OUTPUT
            MODULE_NAME="${BRANCH_NAME#module/}"
            echo "module_name=${MODULE_NAME}" >> $GITHUB_OUTPUT
            echo "üì¶ Module branch detected: ${MODULE_NAME}"
          else
            echo "is_module_branch=false" >> $GITHUB_OUTPUT
            echo "module_name=" >> $GITHUB_OUTPUT
            echo "üöÄ Main branch deployment"
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,format=long
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          provenance: false

      - name: Notify Dokploy via Webhook
        if: success()
        env:
          WEBHOOK_URL: ${{ secrets.DOKPLOY_WEBHOOK_URL_FRONTEND }}
          WEBHOOK_URL_MODULE: ${{ secrets.DOKPLOY_WEBHOOK_URL_FRONTEND_MODULE }}
        run: |
          set +e
          BRANCH_NAME="${{ steps.branch-info.outputs.branch_name }}"
          IS_MODULE="${{ steps.branch-info.outputs.is_module_branch }}"

          # Use module webhook if available for module branches, otherwise use default
          if [ "$IS_MODULE" = "true" ] && [ -n "$WEBHOOK_URL_MODULE" ]; then
            FINAL_WEBHOOK_URL="$WEBHOOK_URL_MODULE"
            echo "Using module webhook for branch: $BRANCH_NAME"
          else
            FINAL_WEBHOOK_URL="$WEBHOOK_URL"
            echo "Using default webhook for branch: $BRANCH_NAME"
          fi

          echo "Calling Dokploy webhook..."
          response=$(curl -X POST "${FINAL_WEBHOOK_URL}" \
            -w "\nHTTP_CODE:%{http_code}" \
            -s \
            --max-time 30)
          curl_exit_code=$?

          echo "Curl exit code: $curl_exit_code"
          echo "Response:"
          echo "$response"

          http_code=$(echo "$response" | grep "HTTP_CODE" | cut -d: -f2)
          echo "HTTP Code: $http_code"

          if [ "$http_code" = "200" ] || [ "$http_code" = "201" ] || [ "$http_code" = "204" ]; then
            echo "‚úÖ Dokploy webhook successful with code: $http_code"
          else
            echo "‚ö†Ô∏è Dokploy webhook failed with code: $http_code (curl exit: $curl_exit_code)"
            echo "Note: This will not fail the deployment as the image was successfully pushed"
          fi
        timeout-minutes: 2

      - name: Notify Backend - Deployment Started
        if: success()
        env:
          BACKEND_WEBHOOK_URL: ${{ secrets.BACKEND_DEPLOYMENT_WEBHOOK_URL }}
          WEBHOOK_SECRET: ${{ secrets.DOKPLOY_WEBHOOK_SECRET }}
        run: |
          set +e
          BRANCH_NAME="${{ steps.branch-info.outputs.branch_name }}"
          IS_MODULE="${{ steps.branch-info.outputs.is_module_branch }}"
          MODULE_NAME="${{ steps.branch-info.outputs.module_name }}"
          COMMIT_SHA="${GITHUB_SHA}"

          if [ "$IS_MODULE" = "true" ]; then
            MESSAGE="Module '${MODULE_NAME}' frontend deployment started"
          else
            MESSAGE="Frontend deployment started via GitHub Actions"
          fi

          PAYLOAD=$(cat <<EOF
          {
            "deploymentId": "gh-${GITHUB_RUN_ID}",
            "applicationId": "frontend",
            "status": "running",
            "branch": "${BRANCH_NAME}",
            "commit": "${COMMIT_SHA}",
            "message": "${MESSAGE}",
            "moduleName": "${MODULE_NAME}",
            "isModuleBranch": ${IS_MODULE},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
EOF
          )

          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | cut -d' ' -f2)

          echo "Notifying backend of deployment start..."
          curl -X POST "${BACKEND_WEBHOOK_URL}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Signature: sha256=${SIGNATURE}" \
            -d "$PAYLOAD" \
            --max-time 10 \
            -s || echo "Backend notification failed (non-blocking)"
        timeout-minutes: 1

  notify-deployment-complete:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Notify Backend - Deployment Complete
        env:
          BACKEND_WEBHOOK_URL: ${{ secrets.BACKEND_DEPLOYMENT_WEBHOOK_URL }}
          WEBHOOK_SECRET: ${{ secrets.DOKPLOY_WEBHOOK_SECRET }}
        run: |
          set +e
          BRANCH_NAME="${{ needs.build-and-push.outputs.branch_name }}"
          IS_MODULE="${{ needs.build-and-push.outputs.is_module_branch }}"
          MODULE_NAME="${{ needs.build-and-push.outputs.module_name }}"
          COMMIT_SHA="${GITHUB_SHA}"

          # Determine status based on previous job
          if [ "${{ needs.build-and-push.result }}" = "success" ]; then
            STATUS="done"
            if [ "$IS_MODULE" = "true" ]; then
              MESSAGE="Module '${MODULE_NAME}' frontend deployed successfully! üéâ"
            else
              MESSAGE="Frontend deployment completed successfully"
            fi
          else
            STATUS="error"
            if [ "$IS_MODULE" = "true" ]; then
              MESSAGE="Module '${MODULE_NAME}' frontend deployment failed ‚ùå"
            else
              MESSAGE="Frontend deployment failed"
            fi
          fi

          PAYLOAD=$(cat <<EOF
          {
            "deploymentId": "gh-${GITHUB_RUN_ID}",
            "applicationId": "frontend",
            "status": "${STATUS}",
            "branch": "${BRANCH_NAME}",
            "commit": "${COMMIT_SHA}",
            "message": "${MESSAGE}",
            "moduleName": "${MODULE_NAME}",
            "isModuleBranch": ${IS_MODULE},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
EOF
          )

          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | cut -d' ' -f2)

          echo "Notifying backend of deployment completion..."
          curl -X POST "${BACKEND_WEBHOOK_URL}" \
            -H "Content-Type: application/json" \
            -H "X-Webhook-Signature: sha256=${SIGNATURE}" \
            -d "$PAYLOAD" \
            --max-time 10 \
            -s || echo "Backend notification failed (non-blocking)"
        timeout-minutes: 1
