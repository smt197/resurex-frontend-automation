import { inject } from '@angular/core';
import { VexRoutes } from '@vex/interfaces/vex-route.interface';
import { ModuleConfig } from '../interfaces/module-config.interface';
import { permissionGuard } from 'src/app/guards/permission.guard';

/**
 * Génère automatiquement les routes pour un module basé sur sa configuration
 *
 * @param config Configuration du module
 * @returns Route Angular générée
 *
 * @example
 * ```typescript
 * // Dans roles.routes.ts
 * import { createModuleRoutes } from '@core/auto-generator/utils/route-generator';
 * import { ROLES_CONFIG } from './roles.config';
 *
 * export const rolesRoutes: VexRoutes = createModuleRoutes(ROLES_CONFIG);
 * ```
 */
export function createModuleRoute(config: ModuleConfig): any {
  const route: any = {
    path: config.route.path,
    data: {
      ...(config.route.routeData || {}),
      moduleConfig: config // Passe la config dans les data de la route
    }
  };

  // Ajouter le guard de permission si des permissions sont définies
  if (config.route.permissions && config.route.permissions.length > 0) {
    route.canActivate = [permissionGuard];
    route.data.permissions = config.route.permissions;
  }

  // Ajouter le resolver si configuré
  if (config.route.resolver && config.route.resolverKey) {
    // Le resolver sera importé dynamiquement
    route.resolve = {
      [config.route.resolverKey]: () => {
        // Import dynamique du resolver
        return import(`../../../pages/${config.moduleName}/${config.moduleName}.resolver`)
          .then(m => m[`${config.moduleName}Resolver`]);
      }
    };
  }

  // Composant chargé dynamiquement
  route.loadComponent = () =>
    import(`../../../pages/${config.moduleName}/${config.moduleName}.component`)
      .then(m => {
        const componentName = `${capitalizeFirst(config.moduleName)}Component`;
        return m[componentName];
      });

  // Gérer les sous-routes si configuré
  if (config.route.loadChildren) {
    route.loadChildren = () =>
      import(`../../../pages/${config.moduleName}/${config.moduleName}.routes`)
        .then(m => m.default || m[`${config.moduleName}Routes`]);
  }

  return route;
}

/**
 * Génère les routes pour un module (peut retourner plusieurs routes si sous-routes)
 *
 * @param config Configuration du module
 * @returns Tableau de routes
 */
export function createModuleRoutes(config: ModuleConfig): VexRoutes {
  return [createModuleRoute(config)];
}

/**
 * Génère les routes pour plusieurs modules
 *
 * @param configs Tableau de configurations de modules
 * @returns Tableau de routes combinées
 *
 * @example
 * ```typescript
 * import { createMultipleModuleRoutes } from '@core/auto-generator/utils/route-generator';
 * import { ROLES_CONFIG } from './pages/roles/roles.config';
 * import { USERS_CONFIG } from './pages/users/users.config';
 *
 * export const autoGeneratedRoutes = createMultipleModuleRoutes([
 *   ROLES_CONFIG,
 *   USERS_CONFIG
 * ]);
 * ```
 */
export function createMultipleModuleRoutes(configs: ModuleConfig[]): VexRoutes {
  return configs.flatMap(config => createModuleRoutes(config));
}

/**
 * Valide une configuration de module avant de générer les routes
 *
 * @param config Configuration à valider
 * @throws Error si la configuration est invalide
 */
export function validateModuleConfig(config: ModuleConfig): void {
  const requiredFields = [
    'moduleName',
    'resourceType',
    'displayName',
    'displayNameSingular',
    'identifierField',
    'identifierType',
    'route',
    'form',
    'actions',
    'data',
    'table',
    'notifications'
  ];

  for (const field of requiredFields) {
    if (!(field in config)) {
      throw new Error(
        `Module config validation error: Missing required field '${field}' in module '${config.moduleName || 'unknown'}'`
      );
    }
  }

  // Valider la route
  if (!config.route.path) {
    throw new Error(
      `Module config validation error: route.path is required for module '${config.moduleName}'`
    );
  }

  // Valider le formulaire
  if (!config.form.fields || config.form.fields.length === 0) {
    throw new Error(
      `Module config validation error: form.fields cannot be empty for module '${config.moduleName}'`
    );
  }

  // Si resolver est activé, vérifier que resolverKey est défini
  if (config.route.resolver && !config.route.resolverKey) {
    throw new Error(
      `Module config validation error: route.resolverKey is required when resolver is enabled for module '${config.moduleName}'`
    );
  }
}

/**
 * Génère des routes avec validation
 *
 * @param config Configuration du module
 * @returns Routes générées
 * @throws Error si la configuration est invalide
 */
export function createValidatedModuleRoutes(config: ModuleConfig): VexRoutes {
  validateModuleConfig(config);
  return createModuleRoutes(config);
}

/**
 * Helper: Capitalise la première lettre d'une chaîne
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Extrait la configuration d'un module depuis les data de la route
 *
 * @param route Route activée
 * @returns Configuration du module si disponible
 */
export function getModuleConfigFromRoute(route: any): ModuleConfig | null {
  return route?.data?.moduleConfig || null;
}
